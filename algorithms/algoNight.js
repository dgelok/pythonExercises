
// We have a loud talking parrot. The "hour" parameter is the current hour time in the range 0..23. We are in trouble if the parrot is talking and the hour is before 7 or after 20. Return True if we are in trouble.

// Given a string, return the string made of its first two chars, so the String "Hello" yields "He". If the string is shorter than length 2, return whatever there is, so "X" yields "X", and the empty string "" yields the empty string "". 


// We want to make a row of bricks that is goal inches long. We have a number of small bricks (1 inch each) and big bricks (5 inches each). Return true if it is possible to make the goal by choosing from the given bricks. This is a little harder than it looks and can be done without any loops.


// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.



// Return the number of times that the string "code" appears anywhere in the given string, except we'll accept any letter for the 'd', so "cope" and "cooe" count.

// Given an argument which is a JSON object with keys in kebab case (kebab-case, here-is-an-example), return an updated JSON object which matches it except with keys in camel case (camelCase, hereIsAnExample).

// const exampleJson = `{
//     "first-name": "Jeff",
//     "last-name": "Green",
//     "city-and-state": "Boston, MA",
//     "zip": "12345-1234"
//     }`
// function convertMe(data) {
// }

// convertMe(exampleJson) 
// Should return: 
// `{
//     "firstName": "Jeff",
//     "lastName": "Green",
//     "cityAndState": "Boston, MA",
//     "zip": "12345-1234"
// }`

// Anagram challenge
// Given two strings, see if the second string is an anagram of the first
// An anagram is a word, phrase, or name that can be rearranged to form another word
// Ex: cinema => iceman

let anagram = (str1, str2) =>{
    if (str1.length !== str2.length) {
        return false
    }

    let myLetters = {}
    for (let i = 0; i<str1.length; i++){
        // add all letter in str1 to myLetters WITH nLetters
        let letter = str1[i]
        if (myLetters[letter]) { //if there's a letter in the object already
            myLetters[letter] += 1
        }
        else { // if the letter isn't in the object already
            myLetters[letter] = 1
        } 
    }

    let secondWordLetters = {}
    for (let j = 0; j<str2.length; j++) {
        // add all second words' letters to secondWordLetters W nLetters
        let newletter = str2[j]
        if (secondWordLetters[newletter]) { //if there's a letter in the object already
            secondWordLetters[newletter] += 1
        }
        else { // if the letter isn't in the object already
            secondWordLetters[newletter] = 1
        } 
    }
    let result = true
    for (let key in myLetters) {
        if (myLetters[key] !== secondWordLetters[key]) {
            result = false
            break
        }
    }
    return result
}

console.log(anagram("cinema ", " iceman"))

// let vs const: const points to memory location that NEVER changes. 
// knock out certain cases at the beginning if possible
// this is called a FREQUENCY COUNTER algorithm 

const anagram = (first, second) => {
    if(first.length !== second.length) { return false };
    const lookup = {};
    for(let eachChar of first){
        lookup[eachChar] ? lookup[eachChar] += 1 : lookup[eachChar] = 1;
    }
    for(let eachChar of second){
        // !!!!
        if(!lookup[eachChar]){
            return false;
        } else {
            lookup[eachChar] -= 1;
        }
    }
    return true;
}